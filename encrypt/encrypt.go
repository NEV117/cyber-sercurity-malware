package encrypt

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"fmt"
	"io"
	"os"
	"time"
)

func EncryptFile(inputPath, outputPath string, key []byte) error {
	// Abre el archivo de entrada
	inputFile, err := os.Open(inputPath)
	if err != nil {
		return fmt.Errorf("error al abrir el archivo de entrada: %v", err)
	}
	defer inputFile.Close()

	// Verifica el tamaño del archivo de entrada
	fileInfo, err := inputFile.Stat()
	if err != nil {
		return fmt.Errorf("error al obtener información del archivo de entrada: %v", err)
	}
	if fileInfo.Size() == 0 {
		return fmt.Errorf("el archivo de entrada está vacío")
	}

	// Crea el archivo de salida para escribir el texto cifrado
	outputFile, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("error al crear el archivo de salida: %v", err)
	}
	defer outputFile.Close()

	// Crea un cifrador AES con la clave proporcionada
	block, err := aes.NewCipher(key)
	if err != nil {
		return fmt.Errorf("error al crear el cifrador: %v", err)
	}

	// Crea un IV (Initialization Vector) aleatorio
	iv := make([]byte, aes.BlockSize)
	if _, err := io.ReadFull(rand.Reader, iv); err != nil {
		return fmt.Errorf("error al generar el IV: %v", err)
	}

	// Escribe el IV en el archivo de salida
	if _, err := outputFile.Write(iv); err != nil {
		return fmt.Errorf("error al escribir el IV en el archivo de salida: %v", err)
	}

	// Crea un stream cifrado usando el cifrador y el IV
	stream := cipher.NewCFBEncrypter(block, iv)

	// Crea un Writer que escribe en el archivo de salida después de cifrar los datos
	writer := &cipher.StreamWriter{S: stream, W: outputFile}

	// Copia los datos del archivo de entrada al Writer (cifrando en el proceso)
	for {
		// Creamos un buffer para almacenar los datos leídos del archivo de entrada
		buffer := make([]byte, 4096)

		// Leemos del archivo de entrada directamente en el buffer
		n, err := inputFile.Read(buffer)
		if err != nil {
			if err != io.EOF {
				return fmt.Errorf("error al leer el archivo de entrada: %v", err)
			}
			// Si no se leyeron datos y no hay error, terminamos la lectura
			if n == 0 {
				break
			}
		}

		// Escribimos los datos leídos (o los que quedan en el buffer) en el archivo de salida
		if _, err := writer.Write(buffer[:n]); err != nil {
			return fmt.Errorf("error al cifrar el archivo: %v", err)
		}

		// Si se leyeron menos bytes de los que hay en el buffer, terminamos la lectura
		if n < len(buffer) {
			break
		}
	}

	time.Sleep(2 * time.Second) // Espera 2 segundos antes de continuar

	return nil
}
