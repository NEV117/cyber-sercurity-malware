package encrypt

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"fmt"
	"io"
	"os"
	"time"
)

func EncryptFile(inputPath, outputPath string, key []byte) error {
	inputFile, err := os.Open(inputPath)
	if err != nil {
		return fmt.Errorf("error al abrir el archivo de entrada: %v", err)
	}
	defer inputFile.Close()

	fileInfo, err := inputFile.Stat()
	if err != nil {
		return fmt.Errorf("error al obtener información del archivo de entrada: %v", err)
	}
	if fileInfo.Size() == 0 {
		return fmt.Errorf("el archivo de entrada está vacío")
	}

	outputFile, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("error al crear el archivo de salida: %v", err)
	}
	defer outputFile.Close()

	block, err := aes.NewCipher(key)
	if err != nil {
		return fmt.Errorf("error al crear el cifrador: %v", err)
	}

	iv := make([]byte, aes.BlockSize)
	if _, err := io.ReadFull(rand.Reader, iv); err != nil {
		return fmt.Errorf("error al generar el IV: %v", err)
	}

	if _, err := outputFile.Write(iv); err != nil {
		return fmt.Errorf("error al escribir el IV en el archivo de salida: %v", err)
	}

	stream := cipher.NewCFBEncrypter(block, iv)
	writer := &cipher.StreamWriter{S: stream, W: outputFile}

	for {
		buffer := make([]byte, 4096)
		n, err := inputFile.Read(buffer)
		if err != nil {
			if err != io.EOF {
				return fmt.Errorf("error al leer el archivo de entrada: %v", err)
			}
			if n == 0 {
				break
			}
		}

		if _, err := writer.Write(buffer[:n]); err != nil {
			return fmt.Errorf("error al cifrar el archivo: %v", err)
		}

		if n < len(buffer) {
			break
		}
	}

	time.Sleep(2 * time.Second)
	return nil
}
