package donut

import (
	"os"
	"os/exec"
	"runtime"
)

// Terminal representa una terminal
type Terminal struct {
	OSType string
}

// NewTerminal crea una nueva instancia de Terminal
func NewTerminal() *Terminal {
	return &Terminal{OSType: runtime.GOOS}
}

// RunCommand ejecuta un comando en la terminal
func (t *Terminal) RunCommand(command string, args ...string) error {
	cmd := exec.Command(command, args...)

	// Si la terminal no está abierta, abrirla
	if !t.IsOpen() {
		err := t.Open()
		if err != nil {
			return err
		}
	}

	// Redirigir la salida del comando al stdout de la terminal
	cmd.Stdout = os.Stdout

	// Ejecutar el comando
	err := cmd.Run()
	if err != nil {
		return err
	}

	return nil
}

// IsOpen verifica si la terminal está abierta
func (t *Terminal) IsOpen() bool {
	var cmd *exec.Cmd
	switch t.OSType {
	case "linux", "darwin":
		cmd = exec.Command("ps", "-e")
	case "windows":
		cmd = exec.Command("tasklist")
	}

	err := cmd.Run()
	return err == nil
}

// Open abre una nueva terminal
func (t *Terminal) Open() error {
	var cmd *exec.Cmd
	switch t.OSType {
	case "linux":
		cmd = exec.Command("x-terminal-emulator")
	case "darwin":
		cmd = exec.Command("open", "-a", "Terminal")
	case "windows":
		cmd = exec.Command("cmd", "/c", "start", "cmd")
	}

	err := cmd.Run()
	if err != nil {
		return err
	}

	return nil
}

// Close cierra la terminal
func (t *Terminal) Close() {
	// No es necesario cerrar nada en este caso
}
